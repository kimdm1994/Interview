# Interview

제어문, 배열, 2차원 배열 실습문제 풀어보기!!

-------

1. 자바

[자바의 특징 및 장점] 
 - JVM이 바이트코드를 운영체제에 맞게 해석해주기 때문에, 이식성이 높은 언어이다.

[변수란 무엇인가] 
 - 변수는 가변하는 숫자를 말하며, 하나의 값을 저장하는 공간이다.

[변수의 종류] : 프리미티브 타입, 참조형, 멤버 변수가 있으며,
 - 프리미티브 타입(기본형)은 논리형(boolean), 문자형(char), 정수형(byte, int, long, short), 실수형(float, double)이 있다.
    - 자료의 실제값을 저장한다.

 - 참조형으로는 String(기본형을 제외한 나머지 타입)
    - 주소값을 값으로 가진다.

 - 멤버 변수는 클래스 영역에 선언된 변수를 말하며, 클래스 변수, 인스턴스 변수가 있다.
    - 클래스 변수는 static이 붙어있는 변수이며, 값을 공유하는 변수이다. (static은 정적을 뜻하며, 변하지 않는 값이라 부른다.)
    - final은 상수, 메소드, 클래스를 정의한 뒤 변하지 못하게 할 떄 사용한다.
    - static final은 클래스에 존재하는 하나의 상수이며, 선언과 동시에 초기화를 해주어야 하는 클래스 상수이다.

[변수의 명명 규칙, 네이밍 규칙]
 - 클래스 이름 / 생성자 이름 : 대문자 시작, 어떤 목적으로 만들어졌는지 유추 가능하게 작성
 - 메소드 이름 : 소문자로 시작, 다음 단어 첫 글자는 대문자로 시작, 클래스는 기능을 담당하므로 동사로 시작
 - 속성 이름 : 첫 글자만 소문자로 시작
 - 상수 이름 : final 상수인 경우에는 모든 글자를 대문자로 표기하고, _MAX_LEVEL 처럼 언더바로 구분하게 한다.

[객체 지향이란] 
 - 하나의 기능을 객체로 만들어서 객체들간의 결합을 통해 하나의 프로그램을 만드는 것을 말합니다.

[객체란 무엇인가]
 - 객체는 속성과 동작으로 구성되어 있으며, 자바에서는 속성을 필드(field)라고 부르고, 기능을 메소드(method)라고 부른다.

[객체지향의 4가지 특성 또는 4대 원칙]
 - 캡슐화 : 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. / 이유 : 외부의 잘못된 값으로 인해 객체가 손상되는 것을 막기 위함
 - 상속 : 자식 클래스가 부모 클래로부터 상속받아 특성과 기능을 물려받는 것, 재정의 함으로써 재사용성을 높인다.
 - 추상화 : 인터페이스로 클래스들의 공통적인 특성(변수, 메소드)들을 묶어 표현하는 것
 - 다형성 : 같은 자료형에 여러 가지 객체를 대입하여 다양한 결과를 산출하는 것을 말한다.

 * 오버로딩 : 하나의 클래스에서 메소드의 이름은 같지만 파라미터가 다른것을 말한다.
 * 오버라이딩 : 부모 클래스의 메소드를 자식 클래스의 용도에 맞게 재정의할 때 사용한다.

[다형성의 장점]
 - 여러 타입의 객체를 하나의 타입으로 관리가 가능하기 때문에 각각 정의하지 않아도 되므로 코드양이 줄어든다.

[추상 클래스]
 - 실체 클래스의 공통적인 부분(변수, 메소드)를 추출해서 선언한 클래스
 - 객체를 생성할 수 없다. 몸통이 없는 클래스 (구현부가 없는 메서드)
 - 실체 클래스와 상속관계
 - 필드와 메서드 이름을 통일하여 유지보수성을 높이고 통일성을 유지할 수 있다는 장점이 있다.

[인터페이스]
 - 추상메서드의 모음이고, 추상메서드가 정의되어있으면 반드시 구현해야한다.

[객체 지향 언어의 장점]
 - 상속을 통해서 재사용성을 높이고, 독립적인 객체를 사용함으로써 생산성을 높일 수 있다.
 - 캡슐화를 통해 유지보수가 간편하다.

[접근제한자]
 - public, private, default, protected
 - public : 어디서나 접근이 가능하다.
 - private : 같은 클래스내에서 접근이 가능하다.
 - default : 같은 패키지 내에서 접근이 가능하다.
 - protected : 같은 패키지 내에서 상속관계이면 접근이 가능하다.

[클래스에 사용 가능한 접근제한자]
 - public, default

[생성자에 사용 가능한 접근제한자]
 - public, protected, default, private

[Final 키워드]
 - final 변수 : 변수를 상수화 시키고, 값의 변경이 불가능하다.
 - final 클래스 : 상속을 허용하지 않는다.
 - final 메소드 : 오버라이딩을 허용하지 않는다.

[오버로딩]
 - 하나의 클래스에서 메소드의 이름은 같지만 파라미터가 다른것을 말한다.
[오버로딩 성립조건]
 - 메소드 이름이 같아야 한다.
 - 매개 변수의 개수 또는 타입이 달라야 한다.
 - 매개 변수는 같고 리턴 타입이 다른 경우는 오버로딩이 성립되지 않는다.

[오버라이딩]
 - 부모 클래스의 메소드를 자식 클래스의 용도에 맞게 재정의할 때 사용한다.

[변수 선언 위치에 따른 변수 종류와 메모리 할당 위치]
 - 클래스 변수 : 클래스 영역 / 클래스가 메모리에 올라갈 때
 - 인스턴스 변수 : 클래스 영역 / 인스턴스가 생성될 때 
 - 지역 변수 : 클래스 이외의 영역(메서드, 생성자, 초기화블럭) / 변수 선언문이 수행 되었을 때

[static 키워드의 의미와 라이프 사이클]
 - 정적이라는 뜻이고, 자바가 컴파일되는 시점에 정의 된다.
 - main static은 main은 메서드 이름이고 프로그램이 시작되면 가장 먼저 실행된다.
 - static을 선언하면 new(메모리 할당)을 하지 않아도 사용이 가능하다.

[매개변수 가변인자 (몇 개 들어올지 모르는 매개변수)로 매개변수를 설정하는 방법]
 - 키워드 ... 을 사용한다.
 - void sum(String ... str)

[return이란?]
 - return은 예약어이다.
 - return은 함수에서 빠져 나가라는 의미이다.
 - 반환형에 따라 return값이 달라진다
 - 반환형이 void이면 return값은 없고, return; 으로 종료할 수는 있다.

[매개변수와 인자의 차이]
 - 매개변수 : 함수 정의 시 나열되는 변수
 - 전달인자 : 함수 호출 시 전달되는 실제 값

[자바의 메소드 호출 방식 // Call by Value, Call by Reference]
 - Call by Value : 메서드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값을 복사하여 보낸다.
 - Call by Reference : 메서드 호출 시 사용되는 인자 값의 메모리에 저장되어있는 주소를 복사하여 보낸다.

[패키지(package)]
 - 자바에서 패키지란 클래스와 인터페이스의 집합을 의미한다.
 - 물리적인 하나의 디렉터리를 의미한다.

[import]
 - 컴파일러에게 소스파일에 사요된 클래스의 패키지에 대한 정보를 제공하는 것

[String과 StringBuilder의 차이점]
 - String은 불변(immutable)의 속성을 갖는다.
 - String을 사용하면 Heap 메모리에 생성되어 어플리케이션 성능에 영향을 끼친다.
 - StringBuffer와 StringBuilder는 가변(mutable)의 속성을 갖는다.
 - StringBuffer와 StringBuilder는 .append(), .delete() 등의 API를 이용하여 동일 객체내에서 문자열을 변경할 수 있다.

[StringBuffer와 StringBuilder의 차이]
 - 동기화 여부의 차이가 있다.
 - StringBuffer는 각 메서드별로 Synchronized Keyword가 존재햐여 멀티스레드 환경에서 동기화를 지원한다.  // 멀티스레드
 - StringBuilder는 동기화를 보장하지 않는다. // 단일 스레드

[Wrapper 클래스]
 - 기본 자료타입을 객체로 다루기 위해서 사용하는 클래스들을 래퍼 클래스라고 한다.
 - 내부값을 비교하기 위해서는 .equals를 사용해야 한다. (객체의 참조 주소를 비교하기 때문에)

[자동 박싱(AutoBoxing)과 자동 언박싱(AutoUnBoxing)]
 - 자동 박싱은 래퍼 클래스에 기본값이 대입될 때, 예를 들어 Integer클래스에 변수로 int값이 대입될 때 자동 박싱이 되어 힙 영역에 Integer 객체가 생성된다.
 - 래퍼클래스에 선언한 변수를 같은 타입의 기본값 변수에 대입할 때 자동 언박싱이 일어난다.

[형변환]
 - String을 parse를 사용하여 기본자료형으로 바꿔줄 수 있다.
 - 기본자료형을 .toString을 사용하여 문자열로 바꿔줄 수 있다.

[java.util.Date와 java.sql.Date]
 - java.util.Date 는 format을 통해 시:분:초 까지 나타낼 수 있다. (Mon Jul 30 11:06:20 PDT 2018)
 - java.sql.Date 는 SQL DATE로 식별 할 수 있도록 시간 관련 값이 없고 날짜 부분만 있다. (2018-07-30)

[Canlendar와 GregorianCalendar]
 - public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay, int minute, int second)
 - Calenar cal = new GregorianCalendar( ?, ?, ?, ?, ?, ?, ?,)
 - https://jamesdreaming.tistory.com/98 // 참고
 - https://smujihoon.tistory.com/12 // 참고

[예외처리 하는 목적]
 - Exception 예외가 발생할 것을 대비하여 미리 예측해 이를 소스상에서 제어하고 처리하도로고 만드는 것

[사용해본 Stream 종류에 대해 설명하세요]
 - 

[자료구조를 사용하는 이유]
 - 데이터를 효율적으로 저장하고 관리하여 메모리를 효율적으로 사용하기 위함
 - 실행시간을 단축시키고 메모리 용량을 절약해준다.

[Vector란?]
 - ArrayList와 동일한 내부구조를 갖고 있고, ArrayList처럼 내부에 값이 추가되면 자동으로 크기가 조절되며 그 다음 객체들은 한 자리씩 뒤로 이동된다.
 - ArrayList와의 차이점으로는 Vector는 동기화된 메소드로 구성되어있기 때문에 멀티 스레드가 동시에 이 메소드를 실행할 수 없다. (하나의 스레드가 완료되어야 다른 스레드들이 실행 가능하다)

> 자료구조는 정보처리기사 공부하며
[시간 복잡도]
 - 시간 복잡도(Time Complexity)는 알고리즘을 수행하는 데 연산들이 몇번 이루어지는 지를 숫자로 표기합니다.
 - 입력한 데이터의 개수를 나타내는 n에 따라 변하게 된다.

[Array vs Linked List] // 출처 : https://asfirstalways.tistory.com/310
 - Array : 논리적 저장 순서와 물리적 저장 순서가 일치하다.
 - Array : 인덱스로 해당 원소에 접근할 수 있다.
 - Array : Big-O(1)에 해당 원소로 접근할 수 있다. random access가 가능하다는 장점이 있다. (Big-O 표기법은 찾아보기 정처기에 나옴)
 - Array : 하지만 삽입 또는 삭제 과정에서 해당 원소에 접근하여 작업을 완료한 뒤 <Big-O(1)>, 또 한 가지의 작업을 추가적으로 해줘야 하기 떄문에, 시간이 더 걸린다.
             배열의 요소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속성이 깨지게 된다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift해줘야 하는 cost가 발생한다. -> <Big-O(n)>
 - Linked List : 위의 cost를 해결하기 위한 자료구조이다. 자기 자신 다음에 어떤 원소인지만을 기억하고 있다.
 - Linked List : 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문에 Searching 과정에 있어 하나하나 다 확인해봐야 한다.
          
[Stack, Queue] // 선형 구조
 - Stack : LIFO(후입선출) 먼저 stack에 들어가게 된 원소는 맨 바닥에 깔리게 된다.
 - Queue : FIFO(선입선출) 먼저 들어간 놈이 먼저 나온다. (정처기 마지막 페이징 문제로 많이나옴)

[Tree] // 비선형 주고
 - 계층적 관계(Hierachical Relationship)을 표현하는 자료구조이다.
 - Node(노드) : 각각의 요소
 - Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선
 - Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드
 - Terminal Node(단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드
 - Internal Node(내부노드, 비단말 노드) : 단말 노드를 제외한 모드 노드로 루트 노드를 포함한다.
 - Binary Tee, Full Binary Tree, Complete Binary Tree 등..

> 쓰레드는 예제코드 작성해보고 이해하기
[제네릭스, 와일드카드...]
 - https://multifrontgarden.tistory.com/104 그냥 가서 보자 정리 잘되있다.

[자바에서 프로세스란?]
 - '실행 중인 프로그램'이며, 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 된다.

[스레드란?]
 - 프로세스의 자원을 이용해서 '실제로 작업을 수행하는 것'

[멀티 프로세스 vs 멀티 스레드]
 - 멀티 프로세스 : 한번에 여러 프로그램을 같이 돌리는 것, 프로세스는 각자의 메모리를 동립적으로 운용하기 때문에 다른 프로세스에 영향을 미치지 않는다.
 - 멀티 스레드 : 한 프로그램 안에서 여러 작업(스레드)을 한번에 하는 것, 공유하고 있는 메모리 자원을 아낄 수 있고 통신의 부담이 적다. 하나의 스레드가 예외를 발생시키면 프로세스 자체가 종료될 수 있어 다른 스레드에게 영향을 미친다.

[동기화(Synchronized)]
 - 두 개 이상의 쓰레드가 하나의 자원을 공유할 때 자원을 보호하기 위해 사용한다.

[데몬쓰레드] // 출처 : https://devbox.tistory.com/entry/Java-%EB%8D%B0%EB%AA%AC%EC%93%B0%EB%A0%88%EB%93%9C
 - 다른 일반 쓰레드의 작업을 돕는 보조적인 열할을 수행하는 쓰레드이다.
 - 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료된다.
 - 무한루프와 조건문을 이용해서 실행 후 대기하고 있다가 특정 조건문이 만족되면 작업을 수행하고 다시 대기하도록 작성 (setDaemon(true)를 호출하기만 하면 된다.)

> ===================io, socket, server, client 는 직접작성해보면서 공부하기=====================

-------------------------

2. DataBase

[DML의 종류]
 - SELECT : 데이터 조회할 때 사용
 - INSERT : 데이터 입력할 때 사용
 - UPDATE : 데이터 내용 변경할 때 사용
 - DELETE : 데이터 내용 삭제할 때 사용

[DDL의 종류]
 - CREATE : 데이터베이스, 테이블 등을 생성할 때 사용
 - ALTER : 테이블 수정할 때 사용
 - DROP : 데이터베이스, 테이블 삭제할 때 사용
 - TRUNCATE : 테이블을 초기화할 때 사용

[DCL의 종류]
 - GRANT : 데이터베이스 사용자에게 특정 작업에 대한 수행권한을 부여
 - REVOKE : 데이터베이스 사용자에게 특정 작업에 대한 수행권한을 박탈, 회수

[TCL의 종류]
 - COMMIT : 트랜잭션의 작업 결과를 저장 반영
 - ROLLBACK : COMMIT 된 시점의 상태로 복원
 - SAVEPOINT : SAVEPOINT를 정의하면 ROLLBACK 할 때, SAVEPOINT 까지 트랜잭션의 일부만 롤백할 수 있다.

[JOIN이란?]
 - 두 개 이상의 테이블을 서로 연결하여 마치 하나의 테이블인 것처럼 보여주며, 데이터를 검색할 때 사용하는 방법

[Inner Join vs Outer Joiun]
 - Inner Join : A와 B에 대해 수행하는 것은, A와 B의 교집합을 말합니다.
 - Outer Join : A와 B에 대해 수행하는 것은, A와 B의 합집합을 말합니다.

[Left Outer Join vs Right Outer Join]
 - Left Outer Join : A의 모든 열 더하기 B에 있는 공통부분을 얻게 된다.
 - Right Outer Join : B의 모든 열 더하기 A에 있는 공통부분을 얻게 된다.

[Equal Join vs None-Equal Join]
 - Equal join : 조인 조건식에 '='를 사용한다. 두 테이블에서 공통적으로 존재하는 컬럼의 값이 일치되는 행을 연결해서 결과를 생성하는 것
 - None-Equal Join : JOIN조건을 '='연산자 이외의 비교 연산자를 사용하는 것을 말한다. ('>=' 등)

[Natural Join.. 뭔가 안쓸거 같아서 패스]

[Self Join]
 - 동일 테이블 사이의 조인을 말한다. FROM 절에 동일 테이블이 두번 이상 나타난다. 
 - 반드시 별칭(Alias)을 사용해야 한다.
 - 사용이유 : 예를들어 선임과 후임으로 분류된다면 같은 ID로 조회할 때, 상사에게 정보를 주거나 할 때 등 사용

[Union과 Join의 차이] // 출처 : https://ko.gadget-info.com/difference-between-join
 - Join : 공통 필드 또는 속성을 공유하는 두 개의 서로 다른 관계에 있는 튜플의 특성을 결합
 - Union : 쿼리에 있는 관계의 튜플을 결합

[Subquery]
 - 다른 쿼리 내부에 포함되어 있는 SELECT 문을 의미한다.
 - 서브쿼리를 포함하고 있는 쿼리를 외부쿼리라 부르며, 서브쿼는 내부쿼리라고 부른다.

[Oracle 객체 종류]
 - [테이블, SQL문, 데이터 사전, 인덱스, 뷰, 시퀀스, 동의어] * 한번씩 다 사용해볼 것

[제약 조건]
 - 데이터의 무결성을 지키기 위해 제한된 조건을 의미한다. (* 무결성이란? 제이터의 정확성과 일관성을 보증하는 것)
 - [Primary key, Foreign Key, UNIQUE, CHECK, DEFAULT]
 - Primary Key : 기본키라고 부르며, 중복X, NULL값 X
 - Foreign Key : 외래키라고 부르며, 두 테이블 사이의 관계, 무결성을 보장해 주는 역할
 - Unique : 중복되지 않는 유일함 부여
 - Check : 특정 조건들로 이루어진 수식을 통해 입력되는 데이터를 검증할 때 사용
 - Default : 값을 입력하지 않았을 때, 자동으로 입력되는 기본 값

[Primary Key 사용 이유]
 - 일관성 없는 데이터가 반복적으로 쌓일 수 있기 때문에 쿼리 속도가 느리고, 원하지 않는 정보 조회 결과를 가져 올 수 있습니다.

[Foreign Key 사용 이유]
 - 외래키는 두 개의 테이블을 연결해주는 연결 다리 역할을 하며, 무결성 조건을 위해 사용한다.

[트랜잭션]
 - 논리적 기능을 수행하기 위한 작업의 단위

[뷰(VIEW)]
 - 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
 - 물리적으로는 존재하지 않지만, 이름은 가지는 가상 테이블이다.
 - 장점 : 논리적 데이터 독립성 제공, 사용자의 데이터관리를 간단하게 해준다, 접근 제어를 통한 자동 보안이 제공
 - 단점 : 독립적인 인덱스를 가질 수 있없다. 뷰의 정의를 변경할 수 없다(ALTER 불가), 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.

[인덱스(INDEX)] // ORACLE에서의 INDEX로 검색했음
 - 인덱스는 테이블에 있는 데이터를 발리 찾기 위한 용도의 데이터베이스 객체이다.
 - 가장 일반적인 B-Tree 인덱스는 인덱스 키(인덱스로 만들 테이블의 컬럼 값)와 이 키에 해당하는 컬럼 값을 가진 테이블의 로우가 저장된 주소 값으로 구성된다.
 - CREATE INDEX [인덱스 명] ON [테이블명](컬럼1, ... , 컬럼N)
 - CREATE[UNIQUE] INDEX [인덱스 명] IN [테이블명](컬럼1, ... , 컬럼N) // 중복 X
 - [장점]
    - 검색과 정렬 속도 향상
    - 작업의 속도 향상
    - 테이블 행의 고유성을 강화
    - 기본 키는 자동으로 인덱스
 - [단점]
    - .mdb 파일 크기가 늘어난다 
    - 여러 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다
    - 인덱스 된 필드에서 데이터를 업데이트 하거나
    - 레코드 추가 삭제 시 성능이 떨어진다
 - [종류] : Clustered, NonClustered

> PL/SQL
[PL/SQL이란?]
 - Oracle`s Procedural Language extension to SQL의 약자이다.
 - 변수정의, 조건처리(IF), 반복처리(LOOP, WHILE, FOR)등을 지원하며, 오라클 자체에 내장되어 있는 Procedure Languare이다.
 - DECLASRE문을 이용하여 정의, 선언문의 사용은 선택 사항 이다.
 - 블록 구조로 되어 있고, PL/SQL자신이 컴파일 엔진을 가지고 있다.

[Procedure(프로시저)]
 - 특정 작업을 수행할 수 있는 이름이 있는 PL/SQL 블록으로서, 매개 변수를 받을 수 있고, 반복적으로 사용할 수 있다.
 - 보통 연속 실행 또는 구현이 복잡한 트랜잭션을 수행하는 PL/SQL블록을 데이터베이스에 저장하기 위해 생성 한다.

[Function(함수)]
 - 보통 값을 계산하고 결과값을 반환하기 위해서 함수를 많이 사용 한다.
 - 대부분 구성이 프로시저와 유사하지만 IN 파라미터만 사용 할 수 있고, 반드시 반환 될 값의 데이터 타입을 RETURN문에 선언해야 한다.

[Package(패키지)]
 - 변수, 상수, 서브프로그램등의 항목을 묶어놓은 객체입니다.
 - 패키지는 컴파일 과정을 거쳐 데이터베이스에 저장되며 다른 프로그램에서 패키지의 항목을 참조하고 실행할 수도 있습니다.
 - 사용하는 이유로는 프로시저같은 서브 프로그램의 수가 기하급수적으로 많아지게되는데, 관리하기 힘들어진다. 이러한 문제를 손쉽게 해결하기위해 나온 개념이다.
 - 패키지는 선언부, 본문, 실행부로 나누어지고 예제문에를 통해 연습해보자.

[트리거]
 - https://s00741.tistory.com/entry/%EC%98%A4%EB%9D%BC%ED%81%B4-%ED%8A%B8%EB%A6%AC%EA%B1%B0-%ED%8A%B8%EB%A6%AC%EA%B1%B0%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

--------------------------------

3. 화면 내용

[JavaScript와 jQuery 차이]
 - jQuery는 자바스크립트를 기초로하는 라이브러리이다.
 - 복잡한 자바스크립트를 더 간단하게 구현해 놓아서 개발할 때 간편하다는 장점이 있다.
 - 자바스크립트의 호환성 문제를 해결했다는 장점이 있다. (자바스크립트 같은 경우는 브라우저마다 처리 방법이 다른 경우가 있다.)
 - 단점 : 자바스크립트보다 처리 속도가 느려질 수 있다.
 
-------------

4. 서블릿 & JSP // https://codevang.tistory.com/191, https://codechasseur.tistory.com/25

[클라이언트와 서버] // 질문 의도를 모르겠음 순서 적음
 1. 사용자가 URL(또는 IP)을 통해 WEB 서버를 호출하고 요청사항을 객체(request)에 담아 전송
 2. WEB 서버는 요청 객체(request)를 받아서 바로 처리하거나 어플리케이션 서버(WAS)로 객체 전달
 3. WAS 서버는 요청에 대한 내용과 요청 객체(request)를 받아 적절히 처리 (필요시 DB 작업)
 4. WAS 서버는 처리 후 결과를 응답 객체(response)에 담아 WEB 서버로 회신
 5. WEB 서버는 응답 객체(response)를 다시 사용자에게 회신
 6. 사용자의 브라우저는 WEB 서버가 보내준 코드를 해석해 화면을 구성하여 출력

[WEB 서버 VS WAS 서버]
 - WEB서버 : 정적 컨텐츠를 제공하는 서버이며, HTML 문서, CSS, 자바스크립트, 이미지, 파일 등 즉시 응답가능한 컨텐츠이다.
 - WAS : 데이터베이스의 조회나 다양한 로직 처리가 필요한 동적 컨텐츠를 제공하며, JSP, SERVLET 구동 환경을 제공해주기 때문에 웹 컨테이너 혹은 서블릿 컨테이너라고도 불린다.

[WEB 서버와 WAS 서버 장단점]
 - WEB 서버의 장점 : 정적인 요청에 대한 처리만 하기 때문에 요청에 대한 처리 속도가 빠르다
                           웹 서버만 구축하면 되기 때문에 비용이 적게든다.
 - WEB 서버의 단점 : 저장된 정보만 보여줄 수 있기 때문에 서비스가 한정적이다.
                           추가/ 수정/ 삭제의 작업 모두 수동적이어서 관리가 힘들다.
 - WAS 서버의 장점 : 다양한 정보를 조합하여 동적으로 생성하여 제공 가능하다.
                           웹 사이트 구조에 따라서 추가/ 수정/ 삭제 등의 작업이 용이하다.
 - WAS 서버의 단점 : 사용자에게 웹 페이지를 전달하기 전에 처리하는 작업이 필요해서 상대적으로 느리다.
                           웹 서버외에 추가적으로 처리를 위한 애플리케이션 서버가 필요하기 때문에 추가 비용이 든다.

[서블릿 컨테이너 VS JSP 컨테이너]
 - 서블릿 컨테이너 : 클라이언트 요청에 따라 서블릿을 수행하는 프로그램이다.
                          자바로 구현되어 있고, 서블릿 표준 API에서 제공하는 추상 클래스와 인터페이스를 구현한 클래스를 제공한다.
 - JSP 컨테이너 : JSP를 서블릿으로 변환하는 프로그램입니다.
                      JSP 컨테이너 역시 서블릿으로 구현된 프로그램이다. 상속관게나 생성되는 서블릿 클래스명만 다르게 생성된다.
                      JSP파일을 서블릿 소스로 변환 및 컴파일까지만 담당하는 프로그램이며, 변환된 서블릿의 수행은 서블릿컨테이너가 담당한다.

[서블릿이란?] // 요약
 - 클라이언트의 요청을 처리하고, 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술

[서블릿 동작 방식] == [서블릿 라이프 사이클]
 1. 사용자(클라이언트)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송합니다.
 2. 요청을 전송받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성합니다.
 3. web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾습니다.
 4. 해당 서블릿에서 service메소드를 호출한 후 클리아언트의 GET, POST여부에 따라 doGet() 또는 doPost()를 호출합니다.
 5. doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다.
 6. 응답이 끝나면 destroy() 메소드를 호출하여 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.

[web.xml 배포서술자란?]
 - 배포 서술자는 Java EE 스펙으로 웹 애플리케이션의 기본적인 설정을 위해 작성하는 파일로, 보통은 WEB-INF/web.xml 파일을 말한다.
 - 배포 서술자는 JSP와 서블릿만으로 구성된 경우에는 web.xml 파일만 사용하면 된다고 한다.

[get과 post의 차이]
 - get : Query String 방식으로 주소줄에 값이 노출됩니다.
          URL에 이어붙기 때문에 길이제한이 있어서 많은 양의 데이터를 보내기 어렵다.
          Select적인 성향을 가지고 있다. 어떤 데이터를 가져와서 보여준다거나 하는 용도로 사용한다.
 - post : 숨겨저서(body안에) 보내진다. 
           많은 양의 데이터를 보내기에도 적합하다(용량제한은 존재)
           form을 이용해서 submit을 하는 형태가 post이다.
           서버의 값이나 상태를 바꾸기 위해서 사용한다.

[forward VS sendRedirect] // 출처 : https://goodncuteman.tistory.com/58
 1) forward 
    - 웹 브라우저에서 Servlet1에게 요청을 보낸다. 
    - Servlet1은 요청을 처리한 후 그 결과를HttpServletRequest에 저장한다.
    - Servlet1은 결과가 저장된 HttpServletRequest와 응답을 위한 HttpServletResponse를 같은 웹 어플리케이션에 있는 Servlet2 또는 JSP로 전송한다.
    - Servlet2는 Servlet1로 부터 받은 HttpServletRequest와 HttpServletResponse를 이용하여 요청을 처리한 후 웹 브라우저에게 결과를 전송한다.
    - 이 때 요청과 응답 1번으로 이루어져 있어 브라우저의 UTL은 변경되지 않는다. 그러므로 forward를 할 때 해당 request와 response를 다른 Servlet이나 JSP로 보내줘야한다.
 2) redirect 
    - HTTP 프로토콜로 정해진 규칙이다.
    - 서버는 클라이언트에게 HTTP 상태코드 302로 응답을 하며 헤더 내의 Location값에 이동할 URL을 추가한다.
    - 클라이언트는 리다이렉션 응답을 받게 되면 헤더에 포함된 URL로 재요청을 보낸다. 
    - 서블릿이나 JSP는 리다이렉트하기 위해 HttpServeltResponse클래스의 sendRedirect() 메서드를 사용한다.

 3) 차이 
    - 가장 중요한 차이점은 redirect에서는 요청과 응답이 서로 다르게 각각 이루어졌다는 것이고, 
    - forward에서는 요청과 응답이 한번만 이루어졌다는 것이다.
    - 또한, redirect는 처음 요청한 URL과 리다이렉트가 일어난 후의 URL이 다르게 변경된다는 점이다. 
    - forward는 요청 URL로 동작된 후에도 같다.  

[서블릿 필터란?]
 - 공통적인 기능들을 서블릿이 호출되기 전에 수행(전처리)되게 하고 싶거나, 서블릿이 호출 되고 난 뒤에 수행(후처리)하고 싶으면 공통적인 기능들을 서블릿 필터로 구현하면 된다.
 - 필터를 사용하면 클라이언트의 요청을 가로채어서 서버 컴포넌트의 공통적인 기능들을 수행시킬 수 있다.

[서블릿 래퍼란?]
 - 글자 그대로 포장하는 프로그램이다.
 - 웹 브라우저와 웹 컴포넌트 사이를 오가는 요청 메시지와 응답 메시지를 포장한다.
 - 래퍼 클래스형태로 구현되고, 포장되는 객체의 종류에 따라 요청 래퍼 클래스와 응답 래퍼 클래스로 나뉘어진다.

[Session과 Cookie]
 1) 세션 특징 
     - 저장 위치 : 웹 서버
     - 저장 형식 : Object
     - 만료 시점 : 브라우저 종료시 삭제 (기간 지정 가능) 
     - 사용하는 자원 : 웹 서버 리소스
     - 용량 제한 : 서버가 허용하는 한 용량제한 없음
     - 속도 : 쿠키보다 느림
     - 보안 : 쿠키보다 좋음
 2) 쿠키 특징
     - 저장 위치 : 클라이언트(=접속자 PC)
     - 저장 형식 : text
     - 만료 시점 : 쿠키 저장시 설정 (브라우저가 종료되도, 만료시점이 지나지 않으면 자동 삭제되지 않음)
     - 사용하는 자원 : 클라이언트 리소스
     - 용량 제한 : 총 300개, 하나의 도메인 당 20개, 하나의 쿠키 당 4KB
     - 속도 : 세션보다 빠름
     - 보안 : 쿠키보다 안좋음

[JSP란?]
 - 자바를 기반으로 하여 서블릿보다는 자바 코드에 덜 의존적인 웹 프로그래밍 언어

[JSP 특징]
 - 객체 지향적
 - 플랫폼에 독립적
 - 네트워크 지향적
 - 높은 보안성
 - 멀티 쓰레드 지원
 - 코드가 친근함

[Servlet VS JSP] // 출처 : https://gmlwjd9405.github.io/2018/11/04/servlet-vs-jsp.html
 - 기능의 차이는 없고 역할의 차이만 있다.

 1) Servlet // 출처 : https://gmlwjd9405.github.io/2018/10/28/servlet.html
     - 웹 기반의 요청에 대한 동적인 처리가 가능한 Server Side에서 돌아가는 Java Program
     - Java 코드 안에 HTMl 코드 (하나의 클래스)
     - 웹 개발을 위해 만든 표준
     - DB와의 통신, 비지니스 로직 호출, 데이터를 읽고 확인하는 작업 등에 유용하다.
     - 서블릿이 수정된 경우 자바 코드를 컴파일한 후 동적인 페이지를 처리하기 때문에 전체 코드를 업데이트하고 다시 컴파일한 후 재배포하는 작업이 필요하다.(개발 생산성 저하)
 2) JSP // 출처 :  https://gmlwjd9405.github.io/2018/11/03/jsp.html
     - HTML 코드 안에 Java 코드
     - Servlet를 보완하고 기술을 확장한 스크립트 방식 표준
     - JSP가 수정된 경우 재배포할 필요가 없이 WAS가 알아서 처리한다.(쉬운 배포)

[JSP 태그] // 출처 : https://hunit.tistory.com/203

[JSP 내장객체] // 출처 : https://gyrfalcon.tistory.com/entry/JSP-%EB%82%B4%EC%9E%A5-%EA%B0%9D%EC%B2%B4-9%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95
 1. request 
    : javax.servlet.ServletRequest(javax.servlet.http.httpRequest)
     + client의 http 요청정보를 저장하고 있는 객체
 2. response
    : javax.servlet.ServletResponse(javax.servlet.http.httpResponse)
     +  http 요청에 대한 응답정보를 저장하는 객체
 3. session
    : javax.servlet.http.HttpSession
     + client 가 서버에 접속했을 때 세션정보를 저장한 객체
 4. pageContext
    : javax.servlet.jsp.PageContext
     + 응답 페이지 실행에 필요한 Context정보를 저장한 객체
 5. out
    : javax.servlet.jsp.JspWriter
     + 응답 페이지 전송을 위한 출력 stream
 6. application
    : javax.servlet.ServletContext
     + 동일한 Application 의 Context 정보를 저장하고 있는 객체 
 7. config -- 설정에 관련
    : javax.servlet.ServletConfig
     + 특정 페이지의 서블릿 설정 정볼르 저장하고 있는 객체
 8. page
    : java.lang.Object
     + 특정 페이지의 서블릿 객체(인스턴스화된 객체)
 9. exception 
    : java.lang.Throwable
     + 예외 처리를 위한 객체

[JSP <c:out>을 사용해야 하는 이유?]
 - html이나 스크립트가 실행되어 위험하다.
 - 엄격한 태그 규칙을 위해 사용한다.
 - 개행문자를 파싱의 차이 때문에 사용한다.
 - 보안성 떄문에 사용한다.
 - JSP view 페이지를 만들 때 XSS공격 방지를 위해 "<c:out>"을 사용하여 막을 수 있다.
 - HTML문자를 탈락(escape)시키는 기능도 가지고 있다.

--------------------

4. AJAX

[ajax란 무엇인가?]
 - AJAX란, JavaScript의 라이브러리중 하나이며 Asynchronous Javascript And Xml(비동기식 자바스크립트와 xml)의 약자이다. 
 - 브라우저가 가지고있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법 이며 
 - JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술이다.
 - 즉, 쉽게 말하자면 자바스크립트를 통해서 서버에 데이터를 요청하는 것이다.

[비동기 방식이란?]
 - 비동기 방식은 웹페이지를 리로드하지 않고 데이터를 불러오는 방식이며 
 - Ajax를 통해서 서버에 요청을 한 후 멈추어 있는 것이 아니라 그 프로그램은 계속 돌아간다는 의미를 내포하고 있다.

[비동기 방식의 장점]
 - 페이지 리로드의 경우 전체 리소스를 다시 불러와야하는데 이미지, 스크립트 , 기타 코드등을 모두 재요청할 경우 불필요한 리소스 낭비가 발생하게 되지만 
 - 비동기식 방식을 이용할 경우 필요한 부분만 불러와 사용할 수 있으므로 매우 큰 장점이 있다

5. Framework

[프레임워크란 무엇인가?]
 - 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 일련의 협업화된 형태로 클래스들을 제공하는 것
 - 구체적이며 확장 가능한 기반 코드를 가지고 있으며, 설계자가 의도하는 여러 디자인 패턴의 집합으로 구성되어 있다.

[프레임워크 VS 라이브러리]
 - 프레임워크는 라이브러리에 뼈대가 되는 클래스들과 그 클래스들의 관계로 만들어진 일종의 '설계의 기본 틀'이 추가된다는 점일 것이다.
 - 설계틀이란 '확장 가능한 기반코드', '재사용 가능한 형태의 협업화된 클래스들'이라는 말과 같은 뜻이다.
 - 라이브러리는 그때그때 필요한 걸 가져다 쓰는 대상이지 기능을 쓰기 위해 필요한 구조에 대해 말해주지 않는다. (설계를 대신 해주진 않는다.)
 - 프레임워크는 차후 사용자들에게 의해 확장될 것을 충분히 고려해서 만들어졌기 때문에 사용자 입장에서는 그저 이것을 가지고, 입맛대로 바꾸고 살을 덧붙여서 프로그램을 완성해나가면 된다.

[프레임워크 특징]
 - 프레임워크가 개발하기 위해 반드시 필요한 것은 아니다. 그러나, 작업 속도를 크게 높이고 단순화 할 수 있으며 반응이 좋고 매력적인 웹앱을 만들 수 있다는 장점이 있다.

[프레임워크 종류] // 출처 : https://www.castingn.com/sourcing/kkultip_detail/110
 - 스트럿츠 프레임워크
 - 스프링 프레임워크
 - 앵귤러 JS
 - 장고 프레임워크
 
[마이바티스란?]
 - 객체 지향 언어인 자바의 관계형 데이터 베이스 프로그래밍을 보다 쉽게 도와주는 프레임 워크

[마이바티스의 장점]
 - 간결한 코드의 처리 (JDBC코드의 생략 가능)
 - SQL문의 분리운영
 - Spring과의 연동으로 자동화된 처리
 - 동적 SQL을 이용한 제어 가능

[메이븐이란?]
 - Apache Maven은 바바용 프로젝트 관리도구로 Apache Ant의 대안으로 만들어졌다. Apache License로 배포되는 오픈 소스 소프트웨어이다.

[메이븐 장점] // 출처 : https://mangkyu.tistory.com/8
 - 라이브러리 관리를 매우 용이하게 해준다.
 - 프로젝트의 작성부터 컴파일, 페이즈 등 프로젝트 라이프사이클에 포함되는 각 테스트를 지원해준다.
 - war파일 기반의 배포용으로도 자주 사용된다.

[스프링 프레임워크란?]
​ - 스프링프레임워크란 엔터프라이즈급 애플리케이션 개발에 필요로하는 경량형 프레임워크입니다. 
 - 프로젝트의 규모가 커질수록 스트럿츠 보다는 스프링 프로젝트가 많이 활용이 되고 있는 추세입니다. 
 - J2EE에서 제공하는 대부분의 기능을 지원하기 때문에 JAVA개발에 있어서 대표적인 프레임워크로 자리잡고 있으며 
 - JDBC를 비롯하여 iBatis, 하이버네이트, JPA등 DB처리를 위해 널리 사용되는 라이브러리와 연동을 지원하고 있습니다. 
 - 또한 전자정부 표준프레임워크의 기반이 되는 기술이기 때문에 스프링 프레임워크의 활용도는 더욱 높아지고 있습니다.

[스프링 프레임워크의 특징]
 - 경량컨테이너로 라이프사이클을 관리하고 필요한 객체를 스프링으로부터 받아옵니다.
 - DI지원하여 객체간의 의존관계 설정이 가능합니다.
 - AOP지원합니다.
 - POJO방식으로 자바객체는 특정한 인터페이스를 구현하고 클라스 상속이 필요치 않습니다.
 - 트랜젝션 처리를 위한 일관된 방법을 제공합니다.
 - 영속성 관련 다양한 API를 지원합니다.
 - API연동을 지원합니다.

[스프링 MVC의 흐름] // 출처: https://min-it.tistory.com/7 [MIN-IT]
 1. 클라이언트(사용자)의 모든 요청은 DispatcherServlet이 받는다.
 2. DispatcherServlet은 hanlderMapping을 통해서 요청에 해당하는 Controller를 실행 시킨다.
 3. Controller는 적절한 서비스 객체를 호출 시킨다.
 4. Service는 DB처리를 위해  DAO를 이용하여 데이터를 요청 한다.
 5.DAO는 mybatis를 이용하는 Mapper를 통해 작업 처리를 한다.
 6. 결과(처리한 데이터)가 mapper->DAO->Service->Controller로 전달된다.
 7. Contorller는 전달된 결과(처리된 데이터)를 View Resolver를 통해 전달 받을 View가 있는지 검색한다.
 8. 전달 받은 View가 있다면 View에게 전달된 결과(처리된 데이터)를 전달한다.
 9. View는 전달받은 결과(처리된 데이터)를 다시 DispatcherServlet에게 전달한다.
 10. DispatcherServlet은 전달받은 결과(처리된 데이터)를 클라이언트에게 전달한다.

[HelloWorld 화면이 나오게 되는 원리] // 출처: https://saurus2.tistory.com/entry/Java-Spring-어떻게-동작-하지-Hello-World-의-원리 [Improving developer saurus2]
 1. 클라이언트 요청 
 2. web.xml 에서 디스패처 서블릿(Dispatcher Servlet) 클라이언트 요청을 핸들링
 3. servlet-context.xml 에서 해당 클래스의 웹요청을 처리하는 컨트롤러를 사용 [HanderMapping으로 Controller 검색]
 4. 해당 Controller 가 요청 처리 후, Home (View) 로 리턴 [뷰의 이름은 /WEB-INF/views/home.jsp 로 바뀐다.
 5. View 에 출력
 
[스프링 IoC(Inversion of Control)란?]
 - 제어의 역전이라고 불린다.
 - 객체의 생성부터 생명주기의 관리까지 객체에 대한 제어권이 바뀐것

[IoC 컨테이너란?]
 - 핵심 Interface : BeanFactory
 - Application Component 중앙 저장소
 - Bean 설정 소스로부터 빈 정의를 읽어들여 빈을 구성하고 제공하는 역할을 한다.
 - ApplicationContext 인터페이스를 구현한 클래스의 오브젝트
 - Application Context는 BeanFactory에 여러가지 기능을 추가한 것.
 - 빈 인스턴스를 생성
 - 의존 관계 설정
 - 빈 제공
 - Bean 등록 과정 Bean은 런타임시점에 ComponentScan이 설정파일들을 읽고 ApplicationContext에 의하여 IoC컨테이너에 등록된다 

[DI란?] // 출처 : https://gmlwjd9405.github.io/2018/11/09/dependency-injection.html
 - 객체 자체가 아니라 Framework에 의해 객체의 의존성이 주입되는 설계 패턴
 - Framework에 의해 동적으로 주입되므로 여러 객체 간의 결합이 줄어든다.
 - Dependency Injection은 Spring Framework에서 지원하는 IoC의 형태
 - 설정에 명시된대로 Container가
   1) bean 객체를 생성하고
   2) 종속성 주입을 수행한다.
      Dependency Injection(의존성 주입)과 Inversion Of Control(제어의 역전)은 같은 의미로 사용된다.
      IoC는 DI를 통해 달성된다.
      IoC(제어의 역전): 프로그램 제어권을 framework가 가져가는 것
      개발자가 모든 제어의 중심이지만 코드 전체에 대한 제어는 framework가 한다.
      개발자가 설정(xml, annotation 등)만 하면 Container가 알아서 처리한다.
      즉, 우리는 Framework 속에서 프로그래밍을 하는 것.

[DI 장점] // 출처 : https://gmlwjd9405.github.io/2018/11/09/dependency-injection.html
 - Reduced Dependencies
 - 종속성이 감소한다.
 - components의 종속성이 감소하면 변경에 민감하지 않다.
 - More Reusable Code
 - 재사용성이 증가한다.
 - 일부 인터페이스의 다른 구현이 필요한 경우, 코드를 변경할 필요없이 해당 구현을 사용하도록 components를 구성할 수 있다.
 - More Testable Code
 - 더 많은 테스트 코드를 만들 수 있다.
 - Mock 객체는 실제 구현의 테스트로 사용되는 객체
 - 종속성을 components에 주입할 수 있는 경우 이러한 종속성의 Mock 구현을 주입할 수 있다.
 - 예를 들어, Mock 객체가 올바른 객체를 반환할 때, null을 반환할 때, 예외가 발생할 때 모두 처리한다.
 - More Readable Code
 - 코드를 읽기 쉬워진다.
 - components의 종속성을 보다 쉽게 파악할 수 있으므로 코드를 쉽게 읽을 수 있다.

[DI 종류]
 -  Setter Injection / Constructor Injection / Method Injection

[AOP란?]
 - 관점 지향 프로그래밍
 - 프로그래밍을 하다보면, 공통적인 기능이 많이 발생한다.
 - 이러한 공통기능을 모든 모듈에 적용하기 위한 방법으로 상속을 이용한다.
 - 상속도 좋은 방법이지만, JAVA에서는 다중 상속이 불가능하다.
 - 이러한 모듈을 상속받아 공통 기능을 부여하기에는 한계가 있다.
 - 기능 구현부분에서 핵심코드와 공통기능코드가 섞여있어서 보기에도 불편하고, 효율성이 떨어진다.
 - AOP방법은 핵심 기능과 공통 기능을 분리 시켜놓고 공통 기능을 필요로 하는 핵심 기능들에서 사용하는 방식이다.

[AOP 주요 용어]
 - Aspect : 공통기능
 - Advice : Aspect의 기능 자체
 - Jointpoint : Advice를 적용해야 되는 부분(ex : 필드, 메소드 / 스프링에서는 메소드만 해당)
 - Pointcut : Jointpoint의 부분으로 실제로 Advice가 적용된 부분
 - Weaving : Advice를 핵심기능에 적용하는 행위

[AOP 태그의 종류]
 - <aop:before> : 메소드 실행전에 advice 실행
 - <aop:after-returning> : 정상적으로 메소드 실행 후에 advice 실행
 - <aop:after-throwing> : 메소드 실행둘 exception 발생시 advice 실행
 - <aop:after> : 메소드 실행 중 exception이 발생해도 advice 실행
 - <aop:around> : 메소드 실핼 전/후 및 exception 발생시 advice 실행
